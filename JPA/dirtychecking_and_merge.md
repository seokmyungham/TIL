# 변경 감지와 병합(merge)

### 결론: 엔티티를 변경할 때는 항상 변경 감지를 사용하자.

---

## 준영속 엔티티

- 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.
- 이미 DB에 한 번 저장되어서 식별자가 존재하는 경우, 데이터를 수정하기 위해 새로 객체를 생성한다면 그 객체는 준영속 상태이다.
- 준영속 엔티티를 수정하는 2가지 방법
    - 변경 감지 기능 사용
    - 병합(merge) 사용

#

### 변경감지 기능 사용

- 영속성 컨텍스트에서 엔티티를 조회한 후에 데이터를 수정한다면
- 트랜잭션 커밋 시점에 Dirty Checking이 동작해서 DB에 UPDATE SQL이 실행된다.

```java

@Transactional
void update(Item itemParam) {
    Item findItem = em.find(Item.class, itemParam.getId());
    findItem.setPrice(itemParam.getPrice()); // 엔티티에서 setter를 사용하는건 안 좋은 방법이다.
}
```

### 병합 사용

- 병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다.

```java

@Transactional
void update(Item itemParam) { // itemParam: 파라미터로 넘어온 준영속 상태의 엔티티
    Item mergeItem = em.merge(itemParam);
```

- 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
- 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다. (병합)
- 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 DB에 UPDATE SQL이 실행된다.

#

### 주의! : 병합을 사용하면 모든 속성이 변경된다.

- 병합시 값이 없으면 null로 업데이트가 될 위험이 있다. (병합은 모든 필드를 교체)
- 더티체킹을 활용하면 원하는 속성만 선택해서 변경할 수 있다.
- 실무에서는 업데이트 기능이 매우 제한적이다.
    - 하지만 병합은 모든 필드를 변경해버리고, 데이터가 없으면 null로 업데이트 해버린다.
    - 보통 변경가능한 데이터만 노출하기 때문에, 병합을 사용하는건 오히려 번거로워진다.

#

## 결론

- 컨트롤러에서 어설프게 엔티티를 생성하지 않는다.
- 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를 명확하게 전달해라 (파라미터, dto)
- 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경해라.

---

## Reference

- [실전! 스프링 부트와 JPA 활용1](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1/dashboard)
