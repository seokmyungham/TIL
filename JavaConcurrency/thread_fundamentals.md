# Java Thread Fundamentals

자바 스레드는 JVM에서 유저 스레드를 생성할 때 시스템 콜을 통해서 커널에서 생성된 `커널 스레드와 1대1로 매핑`되어
최종적으로 `커널에서 관리`된다. 
  
커널은 JVM에서 스레드를 생성할 때 마다 자바 스레드와 대응하는 커널 스레드 1개를 생성한다. 자바에서는 
플랫폼 스레드로 정의되어 있다. 즉 OS 플랫폼에 따라 JVM이 사용자 스레드를 매핑하게 된다.

![image](https://github.com/user-attachments/assets/a6ba9135-d2a4-4163-be16-60e9086c3330)

자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며 스레드 실행 시점을 JVM에서 제어할 수 없다.
새로운 스레드는 현재 스레드와 독립적으로 실행되고 최대 한 번만 시작할 수 있으며 스레드가 종료된 후에는 다시 시작할 수 없다.

#

![image](https://github.com/user-attachments/assets/ab2cdda2-3dc9-48e9-87d4-f3509ff22519)

스레드는 Thread 클래스를 상속하거나, Runnable 인터페이스를 구현해서 생성할 수 있다.  
`start()` 메서드를 통해 스레드를 실행시킬 수 있고, 시스템 커널을 통해서 커널에 커널 스레드 생성을 요청한다.
  
`new Thread().start()`를 통해 메인 스레드가 새로운 스레드를 생성하고 실행하면  
내부적으로 네이티브 메서드인 `start0()`을 호출해서 커널에게 커널 스레드를 생성하도록 시스템 콜을 요청한다.
  
생성된 커널 스레드와 자바 스레드가 1대1로 매핑되고, 커널 스레드는 OS 스케줄러로부터 CPU 할당을 받기까지 실행 대기상태에 존재한다.  
커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM에서 매핑된 자바 스레드의 `run()` 메서드를 호출한다.

![image](https://github.com/user-attachments/assets/2f09b5e5-492d-43b1-af4c-caa13bf0aa78)

메인 스레드에서 `start()`가 아닌 `run()` 메서드를 직접 호출할 경우, 새로운 스레드가 생성되지 않고 직접 호출한 메인 스레드 실행 스택에서 `run()`이 실행된다.
  
스레드는 `run()` 메서드의 코드가 모두 실행되면 자동으로 종료된다. 또한 예외가 발생하는 경우에도 종료되며 이 떄 다른 스레드에 영향을 미치지 않는다.
  
싱글스레드 어플리케이션일 경우 메인 스레드만 종료되면 어플리케이션이 종료되고  
멀티스레드 어플리케이션일 경우 JVM에서 실행되고 있는 모든 스레드가 종료되어야 어플리케이션이 종료된다. (데몬 스레드 제외)
  
동일한 코드를 실행하는 각 스레드의 종료 시점은 처리 시간 및 OS의 스케줄링에 의해 결정되므로 매번 다르게 나올 수 있다.

## Thread Stack

스레드가 생성되면 해당 스레드를 위한 스택이 같이 만들어진다.  
스택은 각 스레드마다 독립적으로 할당되는 공간이기 때문에 스레드 간 접근하거나 공유할 수 없다.  
스택은 OS에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 StackOverFlowError가 발생한다.

스택은 `후입선출` 순서로 이루어지며, `프레임`으로 구성되어 있다.  
프레임은 새 메서드를 호출할 때마다 로컬변수 및 객체 참조 변수와 함께 스택의 맨 위에 생성된다.  
이후 실행이 완료되면 스택 프레임이 제거되고 호출한 메서드로 돌아가서 다음 메서드에 사용할 수 있는 새로운 공간이 만들어진다.

## Thread LifeCycle

