# 사용자 수준 스레드 & 커널 수준 스레드

스레드는 관리 방식에 따라 `사용자 수준 스레드(User Level Thread)`와 `커널 수준 스레드(Kernel Level Thread)`로 구분할 수 있다.

## 사용자 수준 스레드

사용자 수준 스레드는 사용자 프로그램에서 관리하는 스레드를 말한다.
  
사용자 영역에서 스레드 라이브러리(Pthreads, Window Threads, Java Thread(JVM))에 의해 스레드의 생성과 종료, 스레드간 메시지 전달,
스레드의 스켸줄링 보관 등 모든 것을 관리한다.
  
커널은 사용자 수준 스레드에 대해 인식하지 못하며 단일 스레드 프로세스로 취급하고 관리한다.  
커널은 이 프로세스를 스케줄링할 때, 단순히 하나의 스레드가 있는 것으로 간주하고 해당 프로세스 전체에 대해 CPU 자원을 할당한다.

## 커널 수준 스레드

커널 수준 스레드는 운영 체제의 커널이 직접 관리하는 스레드를 말한다.
  
커널이 스레드와 관련된 모든 작업(PCB, TCB 관리/유지)을 관리하고, 커널 스레드의 모든 정보를 알고 있어 커널 스레드는 OS 스케줄러에 의해 스케줄링 된다.
CPU는 커널에 의해 생성된 커널 스레드의 실행만을 담당한다.

## 멀티 스레딩 모델

**CPU는 OS 스케줄러가 예약하는 커널 스레드만 직접적으로 실행시킬 수 있다.** 따라서 사용자 수준 스레드는 커널 수준 스레드와의 매핑이 필요하다.
  
사용자 수준 스레드는 세 가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있다.
- 다대일 스레드 매핑, 일대일 스레드 매핑, 다대다 스레드 매핑

### 다대일 스레드 매핑

다수의 사용자 수준 스레드가 커널 수준 스레드 한 개에 매핑하는 유형으로 `사용자 수준의 스레드 모델`이라 볼 수 있다.

![image](https://github.com/user-attachments/assets/d5cde08f-0f2e-4834-9970-e4cc67a6ffed)

**사용자 프로그램의 스레드 라이브러리가 사용자 수준 스레드의 모든 것들을 관리**하고,  
커널 영역과 사용자 영역은 완전히 분리되어 **CPU는 커널 스레드만 인식하고 실행**한다.
  
- 커널 개입 없이 사용자 스레드끼리의 스위칭이 발생하기 때문에 오버헤드가 적다.  
- 스케줄링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어든다.
- 개별 스레드 단위가 아닌 단일 프로세스 단위로 CPU 코어를 할당하기 때문에 멀티코어를 활용한 병렬처리가 불가능하다.
- 프로세스 내의 사용자 수준 스레드중 한 개가 I/O 작업으로 인해 시스템 호출을 수행하면, 커널은 해당 프로세스를 단일 스레드로 인식하기 때문에 프로세스 전체가 블로킹된 것으로 간주한다. 즉 이 프로세스 내의 다른 사용자 수준 스레드들도 CPU를 사용할 수 없게 된다.

전통적인 스레드 라이브러리에서 사용되었으나 현재는 많이 사용되지 않는다.  
자바 초기 버전의 Green Thread가 이 모델에 해당한다고 볼 수 있다.

### 일대일 스레드 매핑

사용자 수준 스레드와 커널 수준 스레드가 일대일로 매핑하는 유형으로 `커널 수준의 스레드 모델`이라 볼 수 있다.

![image](https://github.com/user-attachments/assets/67466247-c46c-4505-9072-02e192283601)

- 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드에서 커널 모드로 전환해서 스케줄링 해야하는 등의 오버헤드가 발생한다.
- 자원 한정으로 인해 커널 스레드를 무한정으로 생성할 수 없다. 대안으로 `스레드 풀`을 활용하기도 한다.
- 스레드 단위로 CPU를 할당하기 때문에 멀티코어를 활용한 병렬 처리가 가능하다.
- 프로세스 내의 사용자 수준 스레드중 한 개가 I/O 작업으로 인해 대기 상태가 되더라도 다른 스레드를 실행할 수 있다. 즉 멀티 스레드의 동시성을 활용할 수 있다.

대부분의 현대 운영체제에서 사용하는 방식으로 자바에서 Native Thread가 이 모델에 해당한다고 볼 수 있다.
  
`new Thread()`로 생성된 스레드는 실제로 커널 스레드이다.  
JVM이 운영체제의 스레드 관리 기능을 사용하여 Java 스레드와 커널 스레드를 1대1로 매핑하기 때문이다. 따라서 Java에서 생성한 스레드는 커널 스레드의 모든 특성을 가지며, 운영체제에 의해 스케줄링되고 실행된다.
  
스레드 풀도 마찬가지로 `Executors.newFixedThreadPool(10)`과 같이 10개의 스레드를 가진 스레드 풀을 생성한다고 가정했을 때
10개의 `Thread` 객체가 생성되고 각 `Thread`는 하나의 커널 스레드에 매핑된다. 따라서, 운영체제는 10개의 커널 스레드를 관리하게 되며, 이 스레드들은 스레드 풀에 할당된 작업을 처리하게 된다.

### 다대다 스레드 매핑

여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형이다.  
각 커널 수준의 스레드가 사용자 수준의 스레드 한 개 이상과 매핑된다.

![image](https://github.com/user-attachments/assets/23cab10f-17be-441f-bda4-e8e7aa161948)

다대다 모델은 다대일, 일대일 모델의 단점을 어느정도 해결하여 개발자는 필요한 만큼 사용자 수준 스레드를 생성할 수 있어
높은 동시성을 유지할 수 있다.
   
- 사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄할 수 있다.
- 커널 수준 스레드의 수를 제한하면서도 많은 사용자 수준 스레드를 처리할 수 있다.
- 매우 유연한 방식으로, 효율적인 자원 사용과 높은 동시성을 제공한다.
- 하지만 구현이 복잡할 수 있다.

Java 19 버전에서 도입된 `Virtual Thread`가 다대다 스레드 매핑과 밀접한 연관이 있다.

---

### Reference
- [자바 동시성 프로그래밍 \[리액티브 프로그래밍 Part.1\]](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-part1/dashboard)
