# 삽입 정렬(Insertion Sort)

삽입 정렬은 배열의 2번째 데이터부터 시작해서  
그 앞의 데이터들과 크기를 비교한다음, 자신에게 맞는 자리를 찾아 데이터를 삽입하는 알고리즘이다.  
  
삽입 정렬을 할 시 i 번째 데이터의 위치를 정할때, 1번째부터 i-1번째 데이터는 이미 정렬이 되어있는 상태가된다.

#

## 전체회전 수행 (오름차순)

## 4 3 8 1 2 (n=5)

매 회전 시작 전에 i가 가리키는 데이터를 tmp에 미리 저장한다.

### 3 4 8 1 2 (1회전)

i가 2번째 데이터(3)를 가리키고, 앞의 데이터인 4와 비교한다.  
4가 3보다 크므로 4를 뒤로 옮기고 3을 4자리에 삽입한다.

### 3 4 8 1 2 (2회전)

i가 3번째 데이터(8)를 가리키고, 앞의 데이터인 4와 비교한다.  
4는 8보다 작으므로 아무 일도 일어나지 않는다.

#

### 3 4 8 8 2 (3회전)

i가 4번째 데이터(1)를 가리키고, tmp(1)와 앞의 데이터인 8을 비교한다.  
8은 1보다 크므로 8을 뒤로 옮긴다.

### 3 4 4 8 2 (3회전)

tmp(1)을 앞의 데이터인 4와 비교한다.  
4는 1보다 크므로 4를 뒤로 옮긴다.

### 3 3 4 8 2 (3회전)

tmp(1)을 앞의 데이터인 3과 비교한다.  
3은 1보다 크므로 3을 뒤로 옮긴다.

### 1 3 4 8 2 (3회전)

더 이상 비교할 데이터가 없거나, 앞의 데이터가 tmp보다 작으면  
tmp를 그 자리에 삽입한다.

이러한 방법으로 계속 회전을 반복한다.

---

## 알고리즘 특징

### 장점

- 버블 정렬, 삽입 정렬과 더불어 코드가 매우 단순하다.
- 추가적인 공간이 필요하지 않고, 원래 배열 안에서 정렬이 이루어지므로 제자리 정렬(in-place sorting)이다.
- 동일한 값에 대해 기존의 순서가 유지되므로 안정 정렬(stable sort)이다.
- 버블, 삽입 정렬에 비해서는 속도가 빠른편이다.

### 단점

- 버블, 삽입 정렬에 비해 빠르긴 하지만, 여전히 시간 복잡도가 O(n^2) 이므로 비효율적이다.

#

## 시간 복잡도 (평균 O(n^2))

```java
public int[] InsertionSort(int n, int[] arr){
	
    // i가 0이 아닌 1부터 시작
    for(int i=1; i<n; i++) {
    
        // 삽입해야 할 원소를 미리 tmp변수에 저장
        int tmp = arr[i], j;
		
        // i의 바로 앞 원소부터 0번째 원소까지 tmp와 비교
        for(j=i-1; j>=0; j--) {
            if(arr[j] > tmp) arr[j+1] = arr[j];
            
            // arr[j]가 tmp보다 작거나 같으면 tmp의 삽입 위치는 arr[j+1] 
            else break;
        }
        arr[j+1] = tmp;
    }
	
    return arr;
}
```

### 최선의 시나리오 O(n)

비교: n-1
교환: 2(n-1)

### 최악의 시나리오 O(n^2)

비교: (n-1) + (n-2) + (n-3) ... + 2 + 1 = n(n-1)/2
교환: {(n-1) + (n-2) + (n-3) ... + 2 + 1} + 2(n-1)

# 

데이터 배열이 이미 정렬이 되어있는 최선의 경우에는 시간 복잡도가 O(n)으로 단축되는데,  
inner loop에서 단 한번의 비교만 이루어지기 때문에 outer 반복 횟수만큼만 비교 하면 된다. => n-1  
그리고 교환 횟수는 각 tmp와 arr\[j+1]를 outer loop 반복 횟수만큼 교환하기 때문에 2(n-1)이 된다.  
  
데이터 배열이 역으로 정렬된 최악의 경우에는  
각 회전에서 앞의 모든 데이터들이 한 칸씩 뒤로 이동해야 하므로 n(n-1)/2 만큼의 비교 횟수와 거기다 2(n-1)을 더한 교환 횟수가 산출된다.  
그러므로 최악의 경우 시간 복잡도는 O(n^2)) 이다.
