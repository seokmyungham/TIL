# 버블 정렬(Bubble Sort)

버블 정렬(Bubble Sort, sinking sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다.  
원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이라고 한다.

#

## 1회전 수행 (왼 -> 오, 오름차순) 

## 7 2 5 6 1 (n=5)

### 2 7 5 6 1

배열의 1 번째 자료와 두 번째 자료를 비교, 2 번째 자료가 크면 SWAP

### 2 5 7 6 1
  
배열의 2 번째 자료와 세 번째 자료를 비교, 3 번째 자료가 크면 SWAP
  
### 2 5 6 7 1  
  
배열의 3 번째 자료와 네 번째 자료를 비교, 4 번째 자료가 크면 SWAP  

### 2 5 6 1 7

계속해서 비교 반복행위를 (n-1)번째 자료와 n번째 자료까지 비교한다  
  
#

1회전이 끝나면 가장 큰 자료가 맨 뒤로 이동하므로, 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외된다.  
  
이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.  
  
이러한 반복을 n-1회 반복한다.

---

## 알고리즘 특징

### 장점

- 코드도 단순하고, 구현이 매우 간편하다.
- 추가적인 공간이 필요하지 않고, 원래 배열 안에서 정렬이 이루어지므로 제자리 정렬(in-place sorting)이다.
- 동일한 값에 대해 기존의 순서가 유지되므로 안정 정렬(stable sort)이다.

### 단점

- 너무 많은 교환이 일어난다.
- 시간이 오래걸린다.

#

## 시간 복잡도 (평균 O(n^2))

```java
public int[] BubbleSort(int n, int[] arr) {
    
    // 배열 크기 - 1 만큼 회전
    for(int i=0; i<n-1; i++) {
        
        // 각 회전의 비교횟수는 배열 크기 - 1 에서 현재 회전을 뺀 만큼 수행
        for(int j=0; j<n-i-1; j++) {
            
            if(arr[j]>arr[j+1]) {
                int tmp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tmp;
            }
        }
    }
	
    return arr;
}
```


### 최선의 시나리오 O(n^2)

비교: (n-1) + (n-2) + (n-3) ... + 2 + 1 = n(n-1)/2  
교환: X

### 최악의 시나리오 O(n^2)

비교: (n-1) + (n-2) + (n-3) ... + 2 + 1 = n(n-1)/2  
교환: (n-1) + (n-2) + (n-3) ... + 2 + 1 = n(n-1)/2  

#
  
일반적인 경우에는 최선의 시나리오에서도 시간 복잡도는 O(n^2)가 맞다.  
그런데 Bubble Sort를 조금 개선시키면 최선의 경우일 때 시간 복잡도를 O(n) 까지 단축 시킬 수 있다.  
  
바로 각 회전에서 비교 수행을 할 때 자료가 교환되지 않으면, 그 배열은 이미 정렬되었다는 의미로  
더 이상 반복문을 진행시키지 않고 종료시키는 것이다.  

### 개선된 Bubble Sort 최선의 시나리오 O(n)

비교: n-1
교환: X

```java
public int[] BubbleSort(int n, int[] arr) {
    
    // 배열 크기 - 1 만큼 회전
    for(int i=0; i<n-1; i++) {
        
        // 자료 교환이 일어났는지 판단할 수 있는 flag
        boolean swapped = false;

        // 각 회전의 비교횟수는 배열 크기 - 1 에서 현재 회전을 뺀 만큼 수행
        for(int j=0; j<n-i-1; j++) {
        
            if(arr[j] > arr[j+1]) {
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                
                swapped = true;
            }
        }
        
        // 한 회전에서 자료 교환이 한 번도 일어나지 않는다면 이미 정렬되었다는 의미이므로 반복문을 종료시킨다.
        if(!swapped) break;
    }
	
    return arr;
}
```
