# 이분 탐색, 이진 탐색(Binary Search)

이분 탐색 알고리즘은 리스트 배열에서 원하는 데이터를 찾고 싶을 때  
처음부터 순차적으로 찾는 것이 아니라, 구간을 반씩 줄여가면서 탐색하는 알고리즘이다.  
  
단 이분 탐색 알고리즘은 정렬된 배열에서만 사용 가능하다.

## 자바 코드

### 반복문으로 구현
```java

// target이 배열 안에서 몇 번째에 있는지 찾는다.

public int binarySearch(int[] arr, int target) {
    int answer = 0;
    
    // 이진 탐색 알고리즘을 사용하기 위해서는 기본적으로 정렬이 되어있어야 함
    Arrays.sort(arr);
    
    // lt를 배열의 시작점, rt를 배열의 끝점으로 설정
    int lt = 0, rt = arr.length - 1;
	
    // lt가 rt보다 커지면 종료
    while(lt <= rt) {
    
       /**이진 탐색의 핵심인 mid값은 lt와 rt를 더한 값에 2를 나눈 몫이다
        * mid는 target값을 찾는데 사용되는 인덱스로 사용한다
        */
        int mid = (lt + rt) / 2;
        
        // arr[mid]가 만약 target과 일치하면 반복문을 종료
        if(arr[mid] == target) {
            answer = mid + 1;
            break;
        }
        
        // arr[mid]가 target보다 크면 배열에서 arr[mid]보다 같거나 큰 구간은 볼 필요가 없다.
        // 인덱스 rt를 mid보다 1 작은 값으로 바꾸어 구간의 반을 배제한다.
        else if(arr[mid] > target) rt = mid - 1;
        
        // arr[mid]가 target보다 작다면 lt를 mid보다 1 큰 값으로 바꾸어
        // 배열에서 arr[mid]보다 같거나 작은 구간을 배제한다.
        else lt = mid + 1;
    }
	
    return answer;
}
```

## 시간 복잡도

이진 탐색 알고리즘의 시간 복잡도는 O(logN)으로,  
최악의 경우일 때 배열을 순차적으로 처음부터 모두 탐색을 하는 방법 O(N) 보다 효율적이다.  
  
시간 복잡도를 구하는 방법은 만약 N개의 데이터가 있다고 가정했을 때  

- 처음 탐색을 하게 되면 데이터는 N/2 만큼 남는다
- 두번째 탐색 시에 데이터는 1/2 * N/2 만큼 남는다
- 세번째 탐색 시에 데이터는 1/2 * 1/2 * N/2 남는다
- m 번째 탐색 시에 데이터는 (1/2)^m * N 만큼 남는다
- 최악의 경우일 때 데이터는 (1/2)^m * N = 1 이 성립하기 때문에
- 양변에 2^m을 곱하여 2^m = N
- 또 양변에 log2를 취하면 최종 방정식은 m = 밑이 2인 logN 이 된다.
- 최종적으로 빅 오 표기법으로 바꾸면 시간 복잡도는 O(logN) 이다.
