# InnoDB Cluster

MySQL 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 소스-레플리카 구조 형태로 구성해놓는다고 해서 고가용성이 실현된느 것은 아니다. 소스 서버에서 장애가 발생했을 때 레플리카 서버가 자동으로 기존 소스 서버를 대체하는 새로운 소스 서버로 전환되는 것이 아니기 때문이다. 
  
MySQL 서버 자체적으로 `페일오버`를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 떄 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 한다. 즉 레플리카 서버에 설정된 읽기 모드를 해제해야 하며, `스플릿 브레인` 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 한다. 그리고 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 한다. 이러한 작업은 모두 수동으로 처리할 수밖에 없으며 완료되기 까지 적지 않은 시간이 소요된다.
  
대부분의 경우 이 같은 전환 작업을 자동화하는 것을 고려하곤 한다. 따라서 MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 프로그램을 직접 개발해서 사용하거나 혹은 서드파티 HA 솔루션을 사용하게 되는데, 대표적으로 MMM과 MHA 그리고 Ochestrator등이 있다. MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됐다.

## InnoDB Cluster 아키텍처

InnoDB 클러스터를 구성하는 요소는 다음과 같다.

![image](https://github.com/user-attachments/assets/3ed8f7dc-9c2e-421b-9717-fad34d66b0b8)

- 그룹 복제(Group Replication)
  - 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리 역할을 담당한다.
- MySQL 라우터(MySQL Router)
  - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램으로, 애플리케이션이 실행한 쿼리를 직접 한 MySQL 서버로 전달하는 프록시 역할을 한다. 
- MySQL 셸(MySQL Shell)
  - 기존 MySQL 클라이언트보다 좀 더 확장된 기능을 가진 새로운 클라이언트 프로그램으로, 기본적인 SQL 문 실행뿐만 아니라 자바스크립트 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API를 제공한다.
 
InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며, 각 서버는 프라이머리 혹은 세컨더리중 하나로 역할로 동작하게 된다. 여기서 프라이머리는 기존 MySQL 복제에서의 소스 서버라 할 수 있으며, 세컨더리는 레플리카 서버라고 할 수 있다. 그룹 복제에 설정된 모드에 따라 프라이머리는 하나만 존재할 수도 있고 여러 대가 존재할 수도 있다. 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있다. 또한 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 3대 이상으로 구성해야 하는데, 이는 3대로 구성했을 떄부터 MySQL 서버 한대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 떄문이다.
  
InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 `MySQL 라우터에 연결해서 쿼리를 실행`한다. MySQL 라우터는 `InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보`를 지니며 이를 바탕으로 클라이언트의 쿼리를 클러스터 내 적절한 MySQL 서버로 전달한다. 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없으며, `커넥션 정보에는 MySQL 라우터 서버만 설정해두면 된다.`
  
MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하며, 그 외에도 InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러 가지 기능들을 제공한다.
  
InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 `자동으로 해당 서버를 복제 그룹에서 제외`시키며, 라우터는 이러한 `복제 토폴로지 변경을 인지하고 자신이 가진 메타데이터를 갱신`해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에서 정상적으로 동작하는 MySQL 서버로만 전달될 수 있도록 한다.
  
InnoDB 클러스터에서 각 구성 요소들은 상호 유기적으로 동작해서 고가용성를 이뤄내고, 사용자는 수동으로 장애 복구 처리를 할 필요가 없이 모두 자동으로 처리된다.

## 그룹 복제

![image](https://github.com/user-attachments/assets/05d24c02-659b-4596-ad02-88ae430b5f24)

그룹 복제는 MySQL 5.7.17 버전에서 도입된 새로운 복제 방식이며, 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리 로그와 릴레이 로그, GTID를 사용한다. 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향 복제가 이뤄지는 반면, 그룹 복제에서는 하나의 복제 그룹 내에서 양방향 쓰기를 처리하는 서버가 여러 대 존재할 수 있다.

![image](https://github.com/user-attachments/assets/e43c29ad-45ad-4cca-a6e5-f98385aa2f7c)
  
그룹 복제에서도 트랜잭션에 대해 그룹 내 다른 멤버들의 응답을 확인하는 단계가 존재한다. 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션의 정보를 다른 멤버들에 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 `인증(Certify)`하고 최종적으로 커밋 처리를 완료한다. 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 `선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사`해서 문제없이 적용 가능한지를 확인하는 과정이다.
    
그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 여부가 결정되므로 이러한 부분이 기본 복제와의 가장 큰 차이점이라고 볼 수 있다. 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 `합의(Consensus)`라고 하는데, 이는 그룹 멤버들로 부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구하는 것이기 때문이다. 그룹 복제에서는 매 트랜잭션을 처리할 때마다 이 합의 과정을 반드시 거친다. 물론 데이터를 읽기만 하는 트랜잭션에 대해서는 그룹 멤버간의 합의 과정이 필요치 않다.
  
그룹 복제는 기존 복제를 사용하는 환경에서 수동으로 처리하거나 혹은 복잡하게 구현해야 했던 부분들을 빌트인된 형태의 자동화된 기능으로 제공함으로 사용자의 편의성을 증대시켰다. 그룹 복제는 InnoDB 클러스터의 핵심 구성 요소로, InnoDB 클러스터를 제대로 사용하기 위해서는 그룹 복제를 반드시 이해해야 한다.

- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
- 자동 페일오버
- 자동 분산 복구

### 그룹 복제 아키텍처

![image](https://github.com/user-attachments/assets/13658dc1-a0f3-4a22-8e73-8596cf859710)

그룹 복제는 별도의 플러그인으로 구현돼 있으며, 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치돼 있어야 한다. 

![image](https://github.com/user-attachments/assets/bd619cdb-b468-4623-b29b-fa935bfd82f4)

플러그인 최상위 계층에는 플러그인 API 집합이 존재한다. API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달되며, MySQL 서버에서는 MySQL 서버의 시작 또는 복구 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 들을 서버에 전달한다.
  
복제 플러그인 계층은 그룹 복제의 기능이 실질적으로 구현돼 있는 계층이다. 계층 내부는 여러 가지 모듈들로 나눠져 있고, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달된다. 
  
마지막 두 계층은 그룹 통신 시스템 API와 그룹 통신 엔진으로 이루어져 있다. 상위 플러그인 계층은 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용 하며, 그룹 통신 엔진은 `Xcom` 이라고 불리는데 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소다. 그룹 통신 엔진은 그룹 복제를 설정할 때 지정된 별도의 포트(33061)을 통해 통신을 수행한다. 
  
그룹 통신 엔진은 `트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장해주며, 그룹 복제 토폴로지 변경과 그룹 멤버의 장애 등을 감지`한다. 또한 트랜잭션 적용 등을 위한 `그룹 멤버 간의 합의` 처리도 담당한다.
  
그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수이다. 그룹 복제에서는 복제를 처리할 떄 그룹 멤버 간의 합의 절차가 수행되므로, 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 한다. 따라서 하나의 서버에 장애가 발생하더라도 그룹 복제가 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 한다. 따라서 사용자는 그룹 복제를 구성할 때 허용 가능한 서버 수에 따른 전체 서버수를 다음과 같이 계산해서 그룹 복제로 구성할 서버 수를 결정해야 한다.

```
N = 2F + 1 (N: 전체 서버 수, F: 허용하고자 하는 장애 서버 수)
```

### 싱글 프라이머리 모드(그룹 복제 모드)

싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태다. 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다. 
  
싱글 프라이머리 모드로 동작 중인 그룹에서 다음과 같은 상황에 그룹 내 프라이머리 서버가 변경될 수 있다.

- 자발적으로 혹은 예기치않게 프라이머리 서버가 그룹을 탈퇴
- group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우

UDF를 통해 사용자가 지정한 서버로 변경되는 경우가 아닌 경우 그룹 복제에서는 다음과 같은 우선순위들을 바탕으로 새로운 프라이머리를 선출하게 된다.

- MySQL 서버 버전
- 각 멤버의 가중치 값
- UUID값 의 사전식 순서

- 
