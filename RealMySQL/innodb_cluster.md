# InnoDB Cluster

MySQL 복제 기능을 사용해 서비스의 고가용성을 실현할 수 있지만 단순히 소스-레플리카 구조 형태로 구성해놓는다고 해서 고가용성이 실현되는 것은 아니다. 소스 서버에서 장애가 발생했을 때 레플리카 서버가 자동으로 기존 소스 서버를 대체하는 새로운 소스 서버로 전환되는 것이 아니기 때문이다. 
  
MySQL 서버 자체적으로 `페일오버`를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 떄 레플리카 서버가 새로운 소스 서버가 될 수 있도록 일련의 작업들을 수행해야 한다. 즉 레플리카 서버에 설정된 읽기 모드를 해제해야 하며, `스플릿 브레인` 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 실행하지 못하도록 해야 한다. 그리고 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정을 변경해야 한다. 이러한 작업은 모두 수동으로 처리할 수밖에 없으며 완료되기 까지 적지 않은 시간이 소요된다.
  
대부분의 경우 이 같은 전환 작업을 자동화하는 것을 고려하곤 한다. 따라서 MySQL 서버 장애를 감지해 자동으로 페일오버를 처리하는 프로그램을 직접 개발해서 사용하거나 혹은 서드파티 HA 솔루션을 사용하게 되는데, 대표적으로 MMM과 MHA 그리고 Ochestrator등이 있다. MySQL 5.7.17 버전에서 빌트인 형태의 HA 솔루션인 InnoDB 클러스터가 도입되면서 사용자는 좀 더 쉽고 편리하게 고가용성을 실현할 수 있게 됐다.

## InnoDB Cluster 아키텍처

InnoDB 클러스터를 구성하는 요소는 다음과 같다.

![image](https://github.com/user-attachments/assets/3ed8f7dc-9c2e-421b-9717-fad34d66b0b8)

- 그룹 복제(Group Replication)
  - 소스 서버의 데이터를 레플리카 서버로 동기화하는 기본적인 복제 역할뿐만 아니라 복제에 참여하는 MySQL 서버들에 대한 자동화된 멤버십 관리 역할을 담당한다.
- MySQL 라우터(MySQL Router)
  - 애플리케이션 서버와 MySQL 서버 사이에서 동작하는 미들웨어 프로그램으로, 애플리케이션이 실행한 쿼리를 직접 한 MySQL 서버로 전달하는 프록시 역할을 한다. 
- MySQL 셸(MySQL Shell)
  - 기존 MySQL 클라이언트보다 좀 더 확장된 기능을 가진 새로운 클라이언트 프로그램으로, 기본적인 SQL 문 실행뿐만 아니라 자바스크립트 및 파이썬 기반의 스크립트 작성 기능과 MySQL 서버에 대해 클러스터 구성 등의 어드민 작업을 할 수 있게 하는 API를 제공한다.
 
InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며, 각 서버는 프라이머리 혹은 세컨더리중 하나로 역할로 동작하게 된다. 여기서 프라이머리는 기존 MySQL 복제에서의 소스 서버라 할 수 있으며, 세컨더리는 레플리카 서버라고 할 수 있다. 그룹 복제에 설정된 모드에 따라 프라이머리는 하나만 존재할 수도 있고 여러 대가 존재할 수도 있다. 그룹 복제에서는 InnoDB 스토리지 엔진만 사용될 수 있다. 또한 그룹 복제를 구성할 때 고가용성을 위해 MySQL 서버를 최소 3대 이상으로 구성해야 하는데, 이는 3대로 구성했을 떄부터 MySQL 서버 한대에 장애가 발생하더라도 복제 그룹이 정상적으로 동작하기 떄문이다.
  
InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 `MySQL 라우터에 연결해서 쿼리를 실행`한다. MySQL 라우터는 `InnoDB 클러스터로 구성된 MySQL 서버들에 대한 메타데이터 정보`를 지니며 이를 바탕으로 클라이언트의 쿼리를 클러스터 내 적절한 MySQL 서버로 전달한다. 따라서 클라이언트는 현재 InnoDB 클러스터가 어떤 서버로 구성돼 있는지 알고 있을 필요가 없으며, `커넥션 정보에는 MySQL 라우터 서버만 설정해두면 된다.`
  
MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공하며, 그 외에도 InnoDB 클러스터의 상태를 확인하거나 MySQL 서버의 설정을 변경하는 것과 같은 여러 가지 기능들을 제공한다.
  
InnoDB 클러스터에서는 MySQL 서버에 장애가 발생하면 그룹 복제가 먼저 이를 감지해서 `자동으로 해당 서버를 복제 그룹에서 제외`시키며, 라우터는 이러한 `복제 토폴로지 변경을 인지하고 자신이 가진 메타데이터를 갱신`해서 클라이언트로부터 실행된 쿼리가 현재 복제 그룹에서 정상적으로 동작하는 MySQL 서버로만 전달될 수 있도록 한다.
  
InnoDB 클러스터에서 각 구성 요소들은 상호 유기적으로 동작해서 고가용성를 이뤄내고, 사용자는 수동으로 장애 복구 처리를 할 필요가 없이 모두 자동으로 처리된다.

## 그룹 복제

![image](https://github.com/user-attachments/assets/05d24c02-659b-4596-ad02-88ae430b5f24)

그룹 복제는 MySQL 5.7.17 버전에서 도입된 새로운 복제 방식이며, 기존 MySQL 복제 프레임워크를 기반으로 구현되어 내부적으로 Row 포맷의 바이너리 로그와 릴레이 로그, GTID를 사용한다. 기존 복제의 경우 일반적으로 소스-레플리카 형태로 구성되어 단방향 복제가 이뤄지는 반면, 그룹 복제에서는 하나의 복제 그룹 내에서 양방향 쓰기를 처리하는 서버가 여러 대 존재할 수 있다.

![image](https://github.com/user-attachments/assets/e43c29ad-45ad-4cca-a6e5-f98385aa2f7c)
  
그룹 복제에서도 트랜잭션에 대해 그룹 내 다른 멤버들의 응답을 확인하는 단계가 존재한다. 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션의 정보를 다른 멤버들에 전송하고 과반수 이상의 멤버로부터 응답을 전달받으면 그때 해당 트랜잭션을 `인증(Certify)`하고 최종적으로 커밋 처리를 완료한다. 트랜잭션 인증은 인증 대상 트랜잭션이 이미 인증 단계를 통과한 `선행 트랜잭션과 동시점에 동일한 데이터를 변경했는지 충돌 여부를 검사`해서 문제없이 적용 가능한지를 확인하는 과정이다.
    
그룹 내 멤버들의 응답에 따라 전체 복제 그룹에서 해당 트랜잭션의 여부가 결정되므로 이러한 부분이 기본 복제와의 가장 큰 차이점이라고 볼 수 있다. 이처럼 트랜잭션 커밋을 처리할 때 그룹의 다른 멤버들에 대한 응답을 확인하는 과정을 `합의(Consensus)`라고 하는데, 이는 그룹 멤버들로 부터 이 트랜잭션을 복제 그룹에 적용하는 것에 대한 동의를 구하는 것이기 때문이다. 그룹 복제에서는 매 트랜잭션을 처리할 때마다 이 합의 과정을 반드시 거친다. 물론 데이터를 읽기만 하는 트랜잭션에 대해서는 그룹 멤버간의 합의 과정이 필요치 않다.
  
그룹 복제는 기존 복제를 사용하는 환경에서 수동으로 처리하거나 혹은 복잡하게 구현해야 했던 부분들을 빌트인된 형태의 자동화된 기능으로 제공함으로 사용자의 편의성을 증대시켰다. 그룹 복제는 InnoDB 클러스터의 핵심 구성 요소로, InnoDB 클러스터를 제대로 사용하기 위해서는 그룹 복제를 반드시 이해해야 한다.

- 그룹 멤버 관리
- 그룹 단위의 정렬된 트랜잭션 적용 및 트랜잭션 충돌 감지
- 자동 페일오버
- 자동 분산 복구

### 그룹 복제 아키텍처

![image](https://github.com/user-attachments/assets/13658dc1-a0f3-4a22-8e73-8596cf859710)

그룹 복제는 별도의 플러그인으로 구현돼 있으며, 그룹 복제를 사용하기 위해서는 MySQL 서버에 그룹 복제 플러그인이 설치돼 있어야 한다. 

![image](https://github.com/user-attachments/assets/bd619cdb-b468-4623-b29b-fa935bfd82f4)

플러그인 최상위 계층에는 플러그인 API 집합이 존재한다. API를 통해 MySQL 서버에서 그룹 복제 플러그인으로 혹은 그 반대 방향으로 요청이 전달되며, MySQL 서버에서는 MySQL 서버의 시작 또는 복구 트랜잭션 커밋 등의 이벤트를 그룹 복제 플러그인에 전달하고 그룹 복제 플러그인에서는 처리 중인 트랜잭션에 대한 커밋 또는 중단, 릴레이 로그 기록을 위한 요청 들을 서버에 전달한다.
  
복제 플러그인 계층은 그룹 복제의 기능이 실질적으로 구현돼 있는 계층이다. 계층 내부는 여러 가지 모듈들로 나눠져 있고, API를 통해 들어온 요청들은 각각 적절한 모듈로 전달된다. 
  
마지막 두 계층은 그룹 통신 시스템 API와 그룹 통신 엔진으로 이루어져 있다. 상위 플러그인 계층은 그룹 통신 시스템 API를 통해 그룹 통신 엔진과 상호작용 하며, 그룹 통신 엔진은 `Xcom` 이라고 불리는데 그룹 복제에 참여 중인 다른 MySQL 서버들과의 통신 처리를 담당하는 그룹 복제의 핵심 구성 요소다. 그룹 통신 엔진은 그룹 복제를 설정할 때 지정된 별도의 포트(33061)을 통해 통신을 수행한다. 
  
그룹 통신 엔진은 `트랜잭션이 그룹 복제 멤버들에 동일한 순서로 전달될 수 있도록 보장해주며, 그룹 복제 토폴로지 변경과 그룹 멤버의 장애 등을 감지`한다. 또한 트랜잭션 적용 등을 위한 `그룹 멤버 간의 합의` 처리도 담당한다.
  
그룹 복제에서 또 다른 중요한 부분은 바로 그룹 복제를 구성하는 MySQL 서버의 수이다. 그룹 복제에서는 복제를 처리할 떄 그룹 멤버 간의 합의 절차가 수행되므로, 정상적으로 동작하려면 그룹의 과반수에 해당하는 서버가 정상적으로 동작하고 있어야 한다. 따라서 하나의 서버에 장애가 발생하더라도 그룹 복제가 문제없이 처리되려면 적어도 세 대의 서버가 그룹에 존재해야 한다. 따라서 사용자는 그룹 복제를 구성할 때 허용 가능한 서버 수에 따른 전체 서버수를 다음과 같이 계산해서 그룹 복제로 구성할 서버 수를 결정해야 한다.

```
N = 2F + 1 (N: 전체 서버 수, F: 허용하고자 하는 장애 서버 수)
```

### 싱글 프라이머리 모드(그룹 복제 모드)

싱글 프라이머리 모드는 그룹 내에서 쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태다. 싱글 프라이머리 모드로 그룹 복제를 처음 구축하는 경우 그룹 복제 구축을 진행한 MySQL 서버가 프라이머리로 지정된다. 
  
싱글 프라이머리 모드로 동작 중인 그룹에서 다음과 같은 상황에 그룹 내 프라이머리 서버가 변경될 수 있다.

- 자발적으로 혹은 예기치않게 프라이머리 서버가 그룹을 탈퇴
- group_replication_set_as_primary() UDF를 사용해 그룹의 특정 멤버를 새로운 프라이머리로 지정한 경우

UDF를 통해 사용자가 지정한 서버로 변경되는 경우가 아닌 경우 그룹 복제에서는 다음과 같은 우선순위들을 바탕으로 새로운 프라이머리를 선출하게 된다.

- MySQL 서버 버전
- 각 멤버의 가중치 값
- UUID값 의 사전식 순서

### 멀티 프라이머리 모드(그룹 복제 모드)

멀티 프라이머리 모드는 그룹 복제에서 멤버들이 전부 프라이머리로 동작하는 형태로, 클라이언트는 그룹의 어떤 MySQL 서버로든 쓰기와 읽기 요청을 보낼 수 있다. 때문에 무엇보다도 `그룹 멤버 간의 MySQL 버전 호환성이 중요`하다. 멀티 프라이머리 모드를 사용하는 그룹에서는 최적의 호환성과 성능을 위해 그룹의 `모든 멤버가 동일한 MySQL 버전으로 실행`되는 것이 좋다. 만약 서로 다른 MySQL 버전을 사용하는 멤버로 구성된 프라이머리 모드의 그룹 복제에서는 새로 참여하는 멤버가 읽기 전용 모드로 유지될 수 있다.
  
### 그룹 멤버 관리(Group Membership)

```
GR_mysql> SELECT * FROM performance_schema.replication_group_members \G
*************************** 1. row ***************************
  CHANNEL_NAME: group_replication_applier
     MEMBER_ID: a2252f46-639a-11eb-ae0c-0ade3e9a4daf
   MEMBER_HOST: ic-node1
   MEMBER_PORT: 3306
  MEMBER_STATE: ONLINE
   MEMBER_ROLE: PRIMARY
MEMBER_VERSION: 8.0.22
*************************** 2. row ***************************

...

```
그룹 복제에서는 현재 어떤 서버들이 그룹에 참여하고 있는지 그룹 멤버들에 대한 목록과 상태 정보를 내부적으로 관리하고 있으며, 사용자는 `performance_schema`의 `replication_group_members` 테이블을 통해서 그룹 멤버 목록을 확인할 수 있다. 그룹 복제에서는 해당 테이블 데이터를 자동으로 갱신한다.
  
사용자는 `replication_group_members` 테이블 데이터를 통해 그룹 멤버들의 호스트명과 사용하는 포트, UUID 값, MySQL 버전을 확인할 수 있으며, 각 그룹 멤버들의 Role도 알 수 있다. 또한 MEMBER_STATE 칼럼을 통해 멤버의 현재 상태도 확인할 수 있다. (`ONLINE`, `RECOVERING`, `OFFLINE`, `ERROR`, `UNREACHABLE`)
  
그룹 복제가 관리하는 멤버 목록과 상태 정보를 `뷰(VIEW)`라고도 하는데, 그룹 복제에서 멤버는 새로 가입하거나 탈퇴할 수 있으므로 뷰는 특정 시점의 그룹 멤버 목록이다. 뷰는 뷰 ID라는 고유 식별자를 가지며, 그룹 멤버가 변경될 때마다 뷰 ID값이 갱신된다.

```
VIEW ID = [Prefix value]:[Sequence value]

Prefix value: 그룹 복제가 초기화될 떄 생성되며, 그 시점의 타임스탬프를 기반으로 값 생성
Sequence value: 단조 증가하는 정숫값, 그룹에서 멤버가 변경될 때마다 1씩 증가
```

그룹의 현재 뷰 ID 값은 `performance_schema`의 r`eplication_group_member_stats` 테이블에서 VIEW_ID 칼럼을 통해 확인할 수 있다. 그룹에 새로운 멤버가 추가되어 뷰 ID 값이 변경되면 바이너리 로그에도 `View_change`라는 이벤트로 뷰 변경 내역이 기록된다. 

### 그룹 복제에서의 트랜잭션 처리

그룹 복제에서 트랜잭션은 `합의`와 `인증` 단계들을 거친 후 최종적으로 그룹의 각 서버들에 적용된다.

`합의`는 그룹 내 일관된 트랜잭션 적용을 위해 그룹 멤버들에게 트랜잭션 적용을 제안하고 승낙을 받는 과정으로, 그룹 멤버 간 통신 결과를 바탕으로 처리된다.

- 클라이언트가 한 그룹 멤버에서 트랜잭션을 실행하고 커밋 요청 전송
- 해당 그룹 멤버는 `그룹 통신 엔진(XCOM)`을 통해 트랜잭션에서 변경한 데이터에 대한 WriteSet과 트랜잭션이 커밋도리 당시의 gtid_executed 스냅샷 정보, 트랜잭션의 이벤트 로그 데이터 등이 포함된 트랜잭션 데이터를 그룹의 다른 멤버들로 전파
- 그룹 복제의 그룹 통신 엔진에서는 트랜잭션을 전파하면서 Paxos 기반의 프로토콜을 바탕으로 그룹 멤버들 간의 합의를 수행
- 최종적으로 합의가 완료되어 실행된 멤버에서 그룹의 과반수 이상에 해당하는 멤버들로부터 응답 메시지를 전달받으면 해당 멤버는 그다음 프로세스를 진행
- 만약 과반수 이상의 멤버들로부터 응답을 받지 못한 경우 그룹 복제에서 트랜잭션은 적용되지 않고 클라이언트에는 에러 반환

실행된 트랜잭션들은 `합의` 단계를 거친 후 글로벌하게 정렬되어, 각 멤버들에서 모두 동일한 순서로 `인증` 단계를 거치게 된다. 

- 각 멤버들은 전달받은 트랜잭션 WriteSet 데이터와 로컬에서 내부적으로 관리하고 있는 WriteSet 히스토리 데이터를 비교
- 해당 트랜잭션이 이미 인증 단계를 거친 선행 트랜잭션과 동시점에 동일한 데이터를 변경한 것인지 검사해서 트랜잭션 충돌 여부 확인

> 트랜잭션 충돌은 그룹 멤버 전체가 쓰기를 처리할 수 있는 멀티 프라이머리 모드에서만 발생할 수 있다.  
> 인증 단계에서 트랜잭션 충돌이 감지된 트랜잭션은 커밋되지 못하고 롤백  
> 따라서 트랜잭션 충돌이 자주 발생할 수 있는 환경에서는 그룹 복제를 싱글 프라이머리로 사용해 대기 후 처리될 수 있게 하는 것이 더 나은 방법이 될 수 있다.

- 각 트랜잭션이 실행된 로컬 멤버에서는 인증 단계를 거친 후 바이너리 로그에 트랜잭션을 기록하고 최종적으로 커밋을 완료
- 클라이언트는 이 시점에 커밋 요청에 대한 응답을 받는다.
- 원격으로 트랜잭션 데이터를 전달받은 그룹의 다른 멤버들에서는 인증 단계를 수행한 후 함께 전달받은 트랜잭션 로그 데이터를 바탕으로 릴레이 로그 작성
- 그룹 복제의 어플라이어 스레드에서는 릴레이 로그에 기록된 트랜잭션을 실행하고 바이너리 로그에도 기록해서 최종적으로 서버에 해당 트랜잭션을 적용

### 트랜잭션 일관성 수준

그룹 복제에서 각 멤버들은 모두 동일한 트랜잭션을 적용하지만 실제 적용 시점까지 완전히 일치하지는 않는다. 그래서 아주 짧은 순간에 최신 쓰기 변경 사항이 반영이 되기 전 한 멤버에서 예전의 데이터를 읽게 되거나하는 문제가 발생할 수 있다. 그런데 MySQL 8.0.14 버전부터 그룹 복제에서 트랜잭션의 일관성 수준을 설정하는 기능이 도입되면서 `group_replication_consistency` 시스템 변수를 통해 사용자가 트랜잭션 일관성을 선택해서 사용할 수 있게됐다. 
  
#### EVENTUAL 일관성 수준

`EVENTUAL` 수준은 트랜잭션 일관성 수준의 기본 값으로, 시스템 변수가 도입되기 이전의 일관성 수준과 동일하다. `EVENTUAL` 일관성 수준에서는 읽기 전용 및 읽기-쓰기 트랜잭션이 별도의 제약 없이 바로 실행 가능하다. 
  
즉 최종적으로는 그룹 멤버들이 일관된 데이터를 가지게 됨을 의미하지만, 트랜잭션이 직접 실행된 멤버가 아닌 `다른 그룹 멤버들에서는 일시적으로 변경 직전 상태의 데이터`가 읽힐 수 있다. 또한 프라이머리 페일오버가 발생한 경우 새로운 프라이머리가 이전 프라이머리의 트랜잭션을 모두 적용하기 전에 새로운 프라이머리에서 트랜잭션이 실행 가능해서 읽기 트랜잭션이 오래된 데이터를 읽을 수 있고, 읽기-쓰기 트랜잭션의 경우 커밋 시 이전 프라이머리의 트랜잭션과의 충돌로 인해 롤백될 수 있음을 의미한다.

#### BEFORE_ON_PRIMARY_FAILOVER 일관성 수준

`BEFORE_ON_PRIMARY_FAILOVER` 수준은 싱글 프라이머리 모드로 설정된 그룹 복제에서 프라이머리 페일오버가 발생해서 신규 프라이머리가 선출됐을 때만 트랜잭션에 영향을 미친다. 선출된 신규 프라이머리가 `BEFORE_ON_PRIMARY_FAILOVER` 수준을 가지고 있고, 아직 이전 프라이머리의 트랜잭션을 적용하는 경우 유입되는 읽기 전용 및 읽기-쓰기 트랜잭션은 트랜잭션이 모두 적용될 떄 까지 대기한다.
  
신규 프라이머리로 유입되는 트랜잭션의 대기 시간은 신규 프라이머리와 이전 프라이머리 간의 트랜잭션 갭에 따라 달라진다. 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. `wait_timeout` 기본 값은 8시간으로 매우 긴 편이므로 애플리케이션에서 적절히 쿼리의 타임아웃을 설정하는 것이 좋다.
  
새로 유입된 모든 읽기-쓰기 트랜잭션들은 처리가 지연되지만 읽기 전용 트랜잭션에서는 MySQL 서버 모니터링 등을 위한 일부 쿼리들은 바로 실행이 가능하다. 
- `SHOW`, `SET`, `DO`, `EMPTY`, `USE`
- performance_schema, sys db에 대한 SELECT
- information_schema의 processlist select
- 테이블 또는 사용자 정의 함수를 사용하지 않는 select
- stop group_replication
- shutdown 문
- reset persist 문

`BEFORE_ON_PRIMARY_FAILOVER` 일관성 수준은 프라이머리 페일오버가 발생하지 않는 상황에서는 프라이머리로 유입된 트랜잭션들에 아무런 영향을 미치지 않는다. 즉 일반적인 상황에서는 트랜잭션들이 `EVENTUAL` 일관성 수준으로 설정된 트랜잭션처럼 처리된다.

#### BEFORE 일관성 수준

`BEFORE` 일관성 수준에서 읽기 전용 및 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 완료될 떄 까지 대기 후 처리된다. `BEFORE` 일관성 수준으로 설정된 트랜잭션은 항상 최신 데이터를 읽으며, 트랜잭션의 처리 시간은 선행 트랜잭션의 처리 시간에 영향을 받는다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. `BEFORE` 일관성 수준은 트랜잭션에서 반드시 최신 데이터를 읽어야 하며, DB에서 읽기 요청은 적고 쓰기 요청이 많은 경우에 사용하는 것이 좋다. 

#### AFTER 일관성 수준

`AFTER` 일관성 수준은 트랜잭션이 적용되면 해당 시점에 그룹 멤버들이 모두 동기화된 데이터를 갖게 한다. 즉 읽기-쓰기 트랜잭션은 다른 모든 멤버들에서도 해당 트랜잭션이 커밋될 준비가 됐을 때 까지 대기한 후 최종적으로 처리된다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다. 읽기-쓰기 트랜잭션은 다른 멤버들에서 트랜잭션 커밋이 준비될 때 까지 대기해야 하므로 항상 본래의 처리 시간보다 더 많은 시간을 소요하게 된다. 따라서 `AFTER` 일관성 수준은 DB에서 쓰기 요청보다 읽기 요청이 많고, 분산된 최신 읽기를 수행하고자 할 때 사용하는 것이 좋다. 

#### BEFORE_AND_AFTER 일관성 수준

![image](https://github.com/user-attachments/assets/bb3cc649-f20b-4b91-a746-3fee42af94a8)

`BEFORE_AND_AFTER` 일관성 수준은 `BEFORE` 수준과 `AFTER` 수준이 결합된 형태라고 볼 수 있다 읽기-쓰기 트랜잭션은 모든 선행 트랜잭션이 적용될 떄까지 기다린 후 실행되며, 트랜잭션이 다른 모든 멤버들에서도 커밋이 준비되어 응답을 보내면 그때 최종적으로 커밋된다. 읽기 전용 트랜잭션은 모든 선행 트랜잭션이 적용될 때 까지 대기한 후 실행된다. 또한 대기 시간이 MySQL `wait_timeout` 시스템 변수에 설정된 값을 초과하면 `ER_GR_HOLD_WAIT_TIMEOUT` 에러가 클라이언트로 반환된다.
  
### 흐름 제어(Flow Control)

그룹 복제에서는 그룹 멤버 간의 트랜잭션 적용 불균형으로 인해 발생하는 문제를 방지하기 위해 그룹 멤버들의 쓰기 처리량을 조절하는 흐름 제어멤 매커니즘이 구현돼 있다. 멤버 간 트랜잭션 갭을 적게 유지해서 멤버들의 데이터가 최대한 동기화된 상태로 유지될 수 있게 하며, 그룹에 평소와 다른 워크로드가 유입되는 등에 변화에도 빠르게 적응해서 각 멤버들의 쓰기 처리량이 균등할 수 있게 한다.
  
`group_replication_flow_control_mode` 시스템 변수를 통해 흐름 제어 기능의 사용 여부를 설정할 수 있다. 현재는 `QUOTA` 모드밖에 존재하지 않으며 또는 `DISABLED` 값으로 설정할 수 있다. `QUOTA` 모드는 흐름 제어의 기본 모드로 멤버가 정해진 할당량만큼만 쓰기를 처리하도록 제어하는 방식이다. `DISABLED`는 흐름 제어 비활성화로, 현재 트랜잭션을 적용하지 않고 있거나 혹은 아직 적용하지 못한 트랜잭션을 아주 많이 가지고 있더라도 다른 멤버들의 흐름 제어에 영향을 주지 않는다. 

흐름 제어는 각 멤버에서 개별적으로 수행되는데, 멤버에서 `인증 큐 크기`, `적용 큐 크기`, `인증된 총 트랜잭션 수`, `적용된 원격 트랜잭션 수`, `로컬 트랜잭션 수`와 같은 통계 정보들을 수집하여 다른 멤버들에게 공유한다. 통계 정보 데이터 수집 주기는 `group_replication_flow_control_period` 시스템 변수로 설정할 수 있다. 흐름 주기 변수 값은 관리상의 편의를 위해서라도 모든 멤버에서 동일한 값으로 설정하는 것이 좋다.
  
사용자는 인증과 적용 큐 크기에 의한 흐름 제어 임계값을 설정할 수 있다. 인증과 적용 큐에서 대기중인 트랜잭션 수가 각각 해당 변수에 지정된 수를 초과하면 흐름 제어가 작동한다. 

- `group_replication_flow_control_cerfifier_threshold`,
- `group_replication_flow_control_applier_threshold`
  
흐름 제어에서는 통계 정보를 바탕으로 그룹에서 트랜잭션 적용이 가장 뒤쳐진 멤버가 처리할 수 있는 수준으로 멤버의 쓰기 처리량을 계산하게 된다. 이렇게 계산된 값은 멤버에게 바로 적용되지 않고, 흐름 제어에서 멤버에게 할당하는 쓰기 처리량과 관련된 시스템 변수들의 값을 참조해서 최종적으로 할당할 쓰기 처리량을 결정한다.

- `group_replication_flow_control_min_quota`
- `group_replication_flow_control_min_recovery_quota`
- 
  

