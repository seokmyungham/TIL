# 실행 계획

## 실행 계획 분석

### 분석 - table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.  
테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.

```sql
mysql> explain select now();
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+

mysql> explain select now() from dual;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```

실제 DUAL이라는 테이블은 없지만 오라클 RDBMS에 익숙한 사용자를 위해 MySQL 서버는 내부적으로 DUAL이라는 테이블이 있는 것 처럼 작동한다.  
오라클 RDBMS에서는 FROM 절이 없으면 오류가 발생하지만 MySQL 서버는 그렇지 않다.  
별도의 테이블을 사용하지 않는 SELECT 쿼리인 경우 위와 같이 NULL이 표시된다.
  
`<derived N>` 또는 `<union M,N>`과 같이 <>로 둘러싸인 테이블은 임시 테이블을 의미한다.  
만약 `<derived 2>`이면 단위 SELECT 쿼리의 id 값이 2인 실행 계획으로부터 만들어진 파생 테이블을 가리킨다.

```sql
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
|  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
|  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
```

- 첫 번째 라인의 테이블이 <derived2> 라는 것을 보아 이 라인보다 id 값이 2인 라인이 먼저 실행되고, 그 결과가 파생 테이블로 준비돼야 한다는 것을 알 수 있다.
- id 값이 2인 라인을 보면 select_type이 derived이고, table이 de인 테이블을 읽어서 파생 테이블을 생성하는 것을 알 수 있다.
- 첫 번째 라인과 두 번째 라인이 같은 id 값을 가지고 있는 것으로 봐서 <derived2> 와 e 테이블이 조인되는 쿼리라는 것을 알 수 있다.
- 그런데 <derived2> 테이블이 e 테이블보다 먼저 표시됐기 때문에 <derived2>가 드라이빙 테이블이 되고, e 테이블이 드리븐 테이블이 되는 것을 알 수 있다.
- 즉 <derived2> 테이블을 먼저 읽고 e 테이블로 조인을 실행했다는 것을 알 수 있다.

```sql
mysql> explain
    -> select *
    -> from (select de.emp_no from dept_emp de group by de.emp_no) tb, employees e
    -> where e.emp_no=tb.emp_no;
```

### 분석 - partitions 칼럼

partitions 컬럼을 통해 파티션이 여러 개인 테이블에서 불필요한 파티션을 제외하고, 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라낼 수 있다.  
이러한 과정을 파티션 프루닝이라한다.
  
### 분석 - type 칼럼

쿼리 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.  
일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 type 칼럼은 매우 중요한 정보
  
- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

위 접근 방법 중에서 ALL은 풀테이블 스캔을 의미하고, 나머지는 모두 인덱스를 사용하는 접근 방법이다.  
또한 성능이 빠른 순서대로 나열한 것이다.

### system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라 한다.

### const

쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 where 조건절을 가지고 있으며, 반드시 1건을 반환하는 처리 방식을 const라고 한다.  
  
다중 칼럼으로 구성된 프라이머리 키나 유니크 키 중 인덱스의 일부 칼럼만 조건으로 사용할 경우에는 const 타입의 접근 방법을 사용할 수 없다.  
프라이머리 키의 일부만 조건으로 사용할 때는 const가 아닌 ref로 표시되고, 모든 칼럼을 조건으로 사용하면 const 접근 방법을 사용할 수 있다.
  
MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화하기 때문에 const이다.  
`where first_name = (select first_name from employees e2 where emp_no=100001)`  
`where first_name = 'Jasminko'`로 치환된다.

### eq_ref

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행계획에서만 표시된다.  
조인에서 처음 읽은 테이블의 칼럼값을, 그다음 읽어야 할 테이블의 pk나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.  
이 때 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다.
  
두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL이어야 하며, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면
모든 칼럼이 비교 조건에 사용돼야만 eq_ref 접근 방법이 사용될 수 있다.  
  
즉 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

```sql
mysql> explain
    -> select * from dept_emp de, employees e
    -> where e.emp_no=de.emp_no AND de.dept_no='d005';
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref                 | rows   | filtered | Extra |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
|  1 | SIMPLE      | de    | NULL       | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const               | 165571 |   100.00 | NULL  |
|  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY                   | PRIMARY | 4       | employees.de.emp_no |      1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
```

employees 테이블의 emp_no는 pk라서 조건에 일치하는 레코드가 1건만 존재하므로 eq_ref가 표시되는 것

### ref

ref 접근 방법은 조인의 순서와 상관없이 사용되며 pk, 유니크 키 조건도 없다.  
인덱스 종류와 상관없이 동등 조건으로 검색할 때 ref 접근 방법이 사용된다. ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다 빠르지 않다.
하지만 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법중 하나.

```sql
mysql> explain
    -> select * from dept_emp where dept_no='d005';
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

dept_emp 테이블의 pk를 구성하는 칼럼 (dept_no, emp_no) 중 일부 detp_no만 동등 조건으로 사용되었기 때문에 조건에 일치하는 레코드가 1건이라는 보장이 없다.
  
그래서 const가 아닌 ref가 사용되었다.

#

- `const`: 조인의 순서와 관계없이 프라이머리 키나 유니크 키의 모든 칼럼에 대해 동등 조건으로 검색(반드시 1건 레코드 반환)
- `eq_ref`: 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 pk나 유니크 키로 동등 조건 검색(두 번째 테이블은 반드시 1건 레코드 반환)
- `ref`: 조인 순서나 인덱스 종류에 관계없이 동등 조건으로 검색

위 세가지 모두 매우 좋은 접근 방법으로 인덱스의 분포도가 나쁘지 않다면 성능상 문제를 일으키지 않는 방법들이다.  
쿼리를 튜닝할 때도 이 세 가지 접근 방법에 대해서는 크게 신경쓰지 않고 넘어가도 무방

#

### fulltext

fulltext 접근 방법은 MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.  
MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다. 쿼리에서 전문 검색 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면
일반 인덱스의 접근 방법이 const나 eq_ref, ref가 아니면 일반적으로 MySQL은 전문 검색 인덱스를 사용하는 조건을 선택해서 처리한다.
  
전문 검색은 MATCH, AGAINST 구문을 사용해서 실행하는데, 이때 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야만 한다.  
테이블에 전문 인덱스가 없다면 쿼리는 오류가 발생하고 중지될 것이다.
  
일반적으로 쿼리에 전문 검색 조건을 사용하면 MySQL은 주저 없이 fulltext 접근 방법을 사용한다.  
하지만 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 사용하는 range 접근 방법이 더 빨리 처리되는 경우가 많으므로 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 편이 좋다.

### ref_or_null

이 접근 방법은 ref 접근 방법과 같은데, null 비교가 추가된 형태  
실제 업무에서 많이 활용되지는 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억하자

### unique_subquery

where 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방법이다. 이름 의미 그대로 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### index_subquery

