# 테이블 파티셔닝

`테이블 파티셔닝`이란 하나의 테이블을 물리적으로 여러 테이블로 분할해서 데이터를 저장하는 기법을 말한다.  
  
테이블이 파티셔닝되면 내부적으로 여러 테이블로 분할되고, 실제 데이터와 인덱스도 나눠서 저장된다.  
분할된 테이블을 각각 `파티션`이라고 부르며, 사용자 입장에서는 기존처럼 하나의 테이블로 인식해서 사용하게 된다.
  
테이블을 파티셔닝하는 기준은 특정 컬럼이나, 계산식을 기준으로 `날짜/숫자 범위`나 `리스트`, `해시값` 형태가 있다. 

## 테이블 파티셔닝을 사용하는 목적

### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

UPDATE와 DELECT 쿼리 처리를 위해 대상 레코드를 검색하려면 인덱스가 필수적이다. 하지만 인덱스가 커지면 커질수록 SELECT, INSERT, DELETE, UPDATE 작업도 함께 느려지는 단점이 있다. 특히 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 그 영향은 심각해진다. 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.

### 삭제 가능한 이력 데이터를 효율적으로 관리

로그성 데이터들이 저장되는 테이블에 파티셔닝을 적용하는 경우, 보관 기간에 따라 일정 기간 지난 데이터들을 제거할 때 데이터를 직접 삭제하는 것이 아닌 `파티션 드랍`으로 간단히 처리하는 것이 가능하다.  
  
파티션 드랍의 경우 테이블을 드랍하는 것처럼 디스크 공간을 완전히 반납하게 되어 서버 자원도 효율적으로 관리할 수 있다.

### 자원 사용 효율 증가 및 쿼리 성능 향상

데이터 접근 패턴이 특정 범위에 집중되는 경우 테이블 파티셔닝을 적용하면 자원을 효율적으로 사용할 수 있고 쿼리의 성능을 향상시킬 수 있다.
  
게시판처럼 최근에 저장된 데이터들을 위주로 조회하는 경우(게시판 1페이지) 날짜 범위로 파티셔닝하여 각 파티션이 특정 기간의 데이터만을 보유하도록 설정할 수 있다.
  
이 때 쿼리가 특정 날짜 범위의 데이터를 요청할 때, MySQL은 조건 범위에 해당하지 않는 파티션은 쿼리 처리에서 제외시킨다. 
이러한 작업을 `파티션 프루닝(Partition Pruning)`이라 부르는데, 특정 파티션의 인덱스 데이터만 탐색하게 되므로 물리 메모리를 효율적으로 사용할 수 있어
쿼리 성능을 향상시킬 수 있다.
  
이처럼 적절히 테이블을 파티셔닝해서 사용할 수 있다면, DB 서버의 자원 사용량을 최적화하는 것과 더불어 쿼리 응답 시간을 단축시켜 애플리케이션 서비스의 품질을 향상시킬 수 있다.

## MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

### INSERT

INSERT 쿼리가 실행되면 MySQL 서버는 INSERT되는 칼럼 값 중에서 `파티션 키인 reg_date`를 이용해 파티션 표현식을 평가하고 레코드가 저장될 적절한 파티션을 결정한다. 새로 INSERT되는 레코드를 위한 파티션이 결정되면 나머지 과정은 파티션되지 않은 일반 테이블과 동일하게 처리된다.

### UPDATE

UPDATE 쿼리를 실행하려면 변경 대상이 어느 파티션에 저장돼 있는지 찾아야 한다. 이때 UPDATE 쿼리의 WHERE 조건에 파티션 키 칼럼이 조건으로 존재하면 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있다. 하지만 WHERE 조건에 파티션 키 칼럼이 명시되어 있지 않다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 `모든 파티션을 검색`해야 한다.

- 파티션 키 이외의 칼럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경한다.
- 파티션 키 칼럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다. 그리고 변경되는 파티션 키 칼럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.

### 파티션 테이블 검색

- WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
- WHERE 절의 조건이 `인덱스를 효율적으로 사용`할 수 있는가? (인덱스 레인지 스캔)

파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건들이다. WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는지에 따라 인덱스를 효율적으로 사용할 수 있는지에도 영향을 끼친다.

- 파티션 선택 가능 + 인덱스 효율적 사용 가능
  - 쿼리가 가장 효율적으로 처리될 수 있는 상황. 이때는 파티션의 개수와 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔한다.
- 파티션 선택 불가 + 인덱스 효율적 사용 가능
  - 모든 파티션에 대해 인덱스 레인지 스캔을 하게된다.
- 파티션 선택 가능 + 인덱스 효율적 사용 불가
  - 필요한 파티션만 읽을 수 있지만 풀 테이블 스캔을 하게 된다.
- 파티션 선택 불가 + 인덱스 효율적 사용 불가
  - 모든 파티션을 검색해야하고, 풀 테이블 스캔을 해야 한다.  

가능하면 세 번째와 네 번째 방식은 피하는 것이 좋다. 두 번쨰 또한 하나의 테이블에 파티션이 많을 경우 MySQL 서버의 부하가 높아지고 처리 시간도 많이 느려지므로 주의하는 것이 좋다.

### 파티션 테이블의 인덱스 스캔 및 정렬

![image](https://github.com/user-attachments/assets/ee396f5e-8f02-4f9f-833c-5c756877a33a)

MySQL 파티션 테이블에서 인덱스는 모두 로컬 인덱스에 해당한다. 모든 인덱스는 파티션 단위로 생성되며, 테이블 전체 단위의 글로벌 인덱스는 지원하지 않는다.

```SQL
SELECT *
FROM tb_article
WHERE reg_userid BETWEEN 'brew' AND 'toto'
AND reg_date BETWEEN '2009-01-01' AND '2010-12-31'
ORDER BY reg_userid;
```
  
예상을 해보면 각 파티션으로부터 WHERE 조건에 일치하는 레코드를 가져온 후, 각 파티션의 결과를 병합하고 ORDER BY 절을 수행하기 위해 reg_userid 칼럼 값으로 다시 한 번 정렬해야 할 것 같지만 실행 계획을 살펴보면 별도의 정렬을 수행했다는 메시지는 표시되지 않는다. =`Using filesort`
  
실제 MySQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때 각 파티션으로부터 레코드를 정렬된 순서대로 읽으면서 우선순위 큐에 임시로 저장한다. 그리고 우선순위 큐에서 다시 필요한 순서대로 데이터를 가져간다.
  
결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 떄 MySQL 서버가 별도의 정렬 작업을 수행하지는 않는다. 하지만 일반 테이블의 인덱스 스캔처럼 결과를 바로 반환하지는 못하고 내부적으로 큐 처리가 한 번 필요하게 된다. 
  
또한 옵티마이저는 일부 파티션만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않는다. 이렇게 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 배제하는 것을 `파티션 프루닝`이라고 한다. 실행계획의 partitions 칼럼을 통해 통해 옵티마이저가 어떤 파티션만 접근하는 지 알 수 있다. 

## 주의 사항

### 파티션 제약 사항

MySQL 파티션은 5.1 버전부터 도입되어 많은 발전이 있었지만 파티션의 태생적인 한계 떄문에 아직도 많은 제약을 지니고 있다.


```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE ( YEAR(reg_date) ) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

대표적으로

- PK를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 한다.
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있다. 파티션 개별로 인덱스를 변경하거나 추가할 수 없다.
- 최대 8192개의 파티션을 가질 수 있다.
- 파티션 테이블에서는 외래키를 사용할 수 없다.
- 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없다.

일반적으로 가장 크게 미치는 제약 사항은 모든 유니크 인덱스에 파티션 키 칼럼이 포함돼야 한다는 것이다. 위 sql에서도 article_id가 AUTO_INCREMENT를 사용하기 떄문에 article_id로만 PK를 구성해도 충분할 것 같지만 (article_id, reg_date) 칼럼 조합으로 pk를 선정했다. 실제 article_id만으로 유니크한 값을 가지기 떄문에 reg_date 칼럼을 pk에 추가하는 것은 아무런 의미가 없지만 reg_date 칼럼으로 파티션을 적용하기 위해서는 이 방법밖에 없는 것이다.
  
또한 


## Reference 

- [Real MySQL 시즌 1 - Part 2](https://www.inflearn.com/course/real-mysql-part-2/dashboard)
