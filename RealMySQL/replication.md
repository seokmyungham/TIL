# 복제

데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소는 바로 `확장성(Scalability)`과 `가용성(Availability)`이다.
서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인
서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해
가장 일반적으로 사용되는 기술이 바로 `복제(Replication)`다.
  
일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 `소스(Source)` 서버 한 대와 `레플리카(Replica)` 서버를 한 대 이상 함께 구축한다.
이는 서비스의 메인 DB 서버인 소스 서버에 문제가 생겼을 때를 대비하려는 목적이 제일 크지만 그 외에도 이처럼 복제를 통해 레플리카 서버를 구축하는 데는 여러가지 목적이 있다.

### 스케일 아웃(Scale-out)

`스케일 업` 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만 일시적이라는 단점도 있다.
서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다.
  
만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 `스케일 아웃`이라고 하며 스케일 아웃은 스케일 업보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다. 복제를 통해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.

### 데이터 백업

백업에 사용되는 툴들은 DBMS마다 종류와 방식이 다르지만 보통은 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 동일한 서버 내에서 백업이 실행되는 경우, 백업 프로그램과 DBMS가 서버의 자원을 공유하기 때문에 서비스에 영향을 줄 수 있다. 때문에 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다. 이렇게 구축된 백업용 레플리카 서버는 소스 서버가 문제 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다.

### 데이터 분석

DB 서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행되지만 무거운 분석용 쿼리들을 실행하기도 한다. 이로 인해 서비스에서 사용되는 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다.

### 데이터의 지리적 분산

DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 거리만큼 비례해서 늘어난다. 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 복제 아키텍처

![image](https://github.com/user-attachments/assets/e87699b4-4ef5-428d-9e9a-551dbf0d36ec)

MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 `바이너리 로그(Binary Log)`라고 한다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. 바이너리 로그에 기록된 각 변경 정보들을 `이벤트`라고도 한다.
  
- 소스 서버에서 생성된 바이너리 로그가 레플리카로 전송
- 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장하고 자신이 가진 데이터에 반영

위와 같은 과정으로 소스 서버와 레플리카 서버 간에 동기화가 이뤄진다.
  
레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 따로 로컬 디스크에 저장해둔 파일을 `릴레이 로그(Relay Log)`라 한다.

- 바이너리 로그 덤프 스레드
  - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 버이너리 로그 정보를 요청한다. 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 `바이너리 로그 덤프 스레드`를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다. 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
- 레플리케이션 I/O 스레드
  - 복제가 시작되면 레플리카 스레드는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 릴레이 로그로 저장하는 역할을 담당한다.
- 레플리케이션 SQL 스레드
  - 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면, 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 
레플리카 서버에서 I/O 스레드와 SQL 스레드는 서로 독립적으로 동작한다. 만약 SQL 스레드에서 이벤트를 적용하는 게 느리더라도 I/O 스레드는 그것과 무관하게 정상적으로 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다. 또한 레플리카 서버에서 변경 사항을 적용하는 것은 소스 서버가 동작하는 것과 별개로 진행되므로 레플리카 서버에 문제가 생기더라도 소스 서버는 전혀 영향을 받지 않는다.
  
그러나 소스 서버에 문제가 생겨 레플리카 서버의 I/O 스레드가 정상적으로 동작하지 않게되면 복제는 에러를 발생시키고 즉시 중단된다. 하지만 이는 레플리카 서버의 복제 기능만 중단된 것이므로 여전히 레플리카 서버가 쿼리를 처리하는 데는 아무런 문제가 없다. 다만 레플리카 서버의 데이터는 소스 서버로부터 동기화되지 못하기 떄문에 예전 상태의 데이터를 보게 된다.

## 복제 타입

MySQL의 복제 타입은 `바이너리 로그 파일 위치 기반 복제`와 `글로벌 트랜잭션 ID 기반 복제`로 나뉜다.

### 바이너리 로그 파일 위치 기반 복제

MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  
이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 오프셋 조합으로 식별한다. 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들로부터 다시 읽어올 수 있다. 
  
이 떄 중요한 것은 복제에 참여한 MySQL 서버들이 모두 고유한 `server_id` 값을 가지고 있어야 한다는 점이다. 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1이다. 만약 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 `server_id` 값과 동일한 `server_id` 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시한다. 자신의 서버에서 발생한 이벤트로 간주해버리기 때문이다.




