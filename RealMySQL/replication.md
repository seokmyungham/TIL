# 복제

데이터베이스를 사용하고 운영할 때 가장 중요한 두 가지 요소는 바로 `확장성(Scalability)`과 `가용성(Availability)`이다.
서비스에서 발생하는 대용량 트래픽을 안정적으로 처리하기 위해서는 데이터베이스 서버의 확장이 필수적이며, 사용자가 언제든지 안정적인
서비스를 이용할 수 있게 하려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 반드시 뒷받침돼야 한다. 이 두 요소를 위해
가장 일반적으로 사용되는 기술이 바로 `복제(Replication)`다.
  
일반적으로 서비스에서 사용될 DB 서버를 구축할 때는 메인으로 사용될 `소스(Source)` 서버 한 대와 `레플리카(Replica)` 서버를 한 대 이상 함께 구축한다.
이는 서비스의 메인 DB 서버인 소스 서버에 문제가 생겼을 때를 대비하려는 목적이 제일 크지만 그 외에도 이처럼 복제를 통해 레플리카 서버를 구축하는 데는 여러가지 목적이 있다.

### 스케일 아웃(Scale-out)

`스케일 업` 방법은 애플리케이션 단의 큰 변화 없이 늘어난 트래픽을 처리할 수 있다는 장점이 있지만 일시적이라는 단점도 있다.
서버의 사양을 업그레이드한다 하더라도 한 대에서 처리할 수 있는 양에는 한계가 있기 때문이다.
  
만약 동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있을 것이다. 이 같은 방법을 `스케일 아웃`이라고 하며 스케일 아웃은 스케일 업보다 갑자기 늘어나는 트래픽을 대응하는 데 훨씬 더 유연한 구조다. 복제를 통해 DB 서버를 스케일 아웃할 수 있으며, 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있다.

### 데이터 백업

백업에 사용되는 툴들은 DBMS마다 종류와 방식이 다르지만 보통은 데이터가 저장돼 있는 DB 서버에서 백업 프로그램이 실행되어 백업을 진행한다. 동일한 서버 내에서 백업이 실행되는 경우, 백업 프로그램과 DBMS가 서버의 자원을 공유하기 때문에 서비스에 영향을 줄 수 있다. 때문에 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행한다. 이렇게 구축된 백업용 레플리카 서버는 소스 서버가 문제 생겼을 때를 대비한 대체 서버의 역할을 하기도 한다.

### 데이터 분석

DB 서버에서는 기본적으로 서비스에서 사용되는 쿼리들이 실행되지만 무거운 분석용 쿼리들을 실행하기도 한다. 이로 인해 서비스에서 사용되는 쿼리들이 영향을 받을 수 있으므로 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋다.

### 데이터의 지리적 분산

DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 거리만큼 비례해서 늘어난다. 사용자에게 빠른 응답 속도를 제공하려면 애플리케이션 서버와 DB 서버가 가깝게 위치하는 것이 좋다. 만약 떨어져 있는 DB 서버의 위치를 이동시키지 못한다면 복제를 사용해 애플리케이션 서버가 위치한 곳에 기존 DB 서버에 대한 레플리카 서버를 새로 구축해 사용함으로써 응답 속도를 개선할 수 있다.

## 복제 아키텍처

![image](https://github.com/user-attachments/assets/e87699b4-4ef5-428d-9e9a-551dbf0d36ec)

MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 `바이너리 로그(Binary Log)`라고 한다. 바이너리 로그에는 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장된다. 바이너리 로그에 기록된 각 변경 정보들을 `이벤트`라고도 한다.
  
- 소스 서버에서 생성된 바이너리 로그가 레플리카로 전송
- 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장하고 자신이 가진 데이터에 반영

위와 같은 과정으로 소스 서버와 레플리카 서버 간에 동기화가 이뤄진다.
  
레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 따로 로컬 디스크에 저장해둔 파일을 `릴레이 로그(Relay Log)`라 한다.

- 바이너리 로그 덤프 스레드
  - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 버이너리 로그 정보를 요청한다. 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 `바이너리 로그 덤프 스레드`를 생성해서 바이너리 로그의 내용을 레플리카 서버로 전송한다. 바이너리 로그 덤프 스레드는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
- 레플리케이션 I/O 스레드
  - 복제가 시작되면 레플리카 스레드는 I/O 스레드를 생성하고, 복제가 멈추면 I/O 스레드는 종료된다. I/O스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 릴레이 로그로 저장하는 역할을 담당한다.
- 레플리케이션 SQL 스레드
  - 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면, 레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
 
레플리카 서버에서 I/O 스레드와 SQL 스레드는 서로 독립적으로 동작한다. 만약 SQL 스레드에서 이벤트를 적용하는 게 느리더라도 I/O 스레드는 그것과 무관하게 정상적으로 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다. 또한 레플리카 서버에서 변경 사항을 적용하는 것은 소스 서버가 동작하는 것과 별개로 진행되므로 레플리카 서버에 문제가 생기더라도 소스 서버는 전혀 영향을 받지 않는다.
  
그러나 소스 서버에 문제가 생겨 레플리카 서버의 I/O 스레드가 정상적으로 동작하지 않게되면 복제는 에러를 발생시키고 즉시 중단된다. 하지만 이는 레플리카 서버의 복제 기능만 중단된 것이므로 여전히 레플리카 서버가 쿼리를 처리하는 데는 아무런 문제가 없다. 다만 레플리카 서버의 데이터는 소스 서버로부터 동기화되지 못하기 떄문에 예전 상태의 데이터를 보게 된다.

## 복제 타입

MySQL의 복제 타입은 `바이너리 로그 파일 위치 기반 복제`와 `글로벌 트랜잭션 ID 기반 복제`로 나뉜다.

### 바이너리 로그 파일 위치 기반 복제

MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식으로, 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태를 말한다.
  
이벤트 하나하나를 소스 서버의 바이너리 로그 파일명과 파일 내에서의 오프셋 조합으로 식별한다. 레플리카 서버에서는 이처럼 각 이벤트들을 식별하고 자신의 적용 내역을 추적함으로써 복제를 일시적으로 중단할 수 있으며 재개할 때도 자신이 마지막으로 적용했던 이벤트 이후의 이벤트들로부터 다시 읽어올 수 있다. 
  
이 떄 중요한 것은 복제에 참여한 MySQL 서버들이 모두 고유한 `server_id` 값을 가지고 있어야 한다는 점이다. 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1이다. 만약 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 `server_id` 값과 동일한 `server_id` 값을 가지는 경우 레플리카 서버에서는 해당 이벤트를 적용하지 않고 무시한다. 자신의 서버에서 발생한 이벤트로 간주해버리기 때문이다.

> 레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속할 DB 계정이 필요하다. 복제에서 사용되는 계정의 비밀번호는 레플리카 서버의 커넥션 메타데이터에 평문으로 저장되므로 보안을 고려해서 복제에 사용되는 권한만 주어진 별도의 계정을 새로 생성해 사용하는 것이 좋다.

### 글로벌 트랜잭션 ID 기반 복제

MySQL 5.5 버전까지는 복제를 설정할 때 바이너리 로그 파일 위치 기반 복제 방식만 가능했다. 문제는 로그 파일명과 파일 내 위치 값 식별 조합이 바이너리 로그 파일이 저장돼 있는 소스 서버에서만 유효하다는 것이다. 동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없다. 한마디로 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게 되는 것이다.
  
이러한 문제는 복제 토폴로지를 변경하는 작업을 거의 불가능하게 만든다. 복제 토폴로지 변경은 주로 복제에 참여하는 서버들 중에서 일부 서버에 장애가 발생했을 때 필요한데, 토폴로지 변경이 어렵다는 것은 그만큼 복제를 이용한 장애 복구가 어렵다는 것을 의미한다.
  
소스 서버에서만 유효한 고유 식별 값이 아닌 복제에 참여한 전체 MySQL 서버들에서 고유하도록 각 이벤트에 부여된 식별 값을 `글로벌 트랜잭션 아이디(GTID)`라고 하며, 이를 기반으로 복제가 진행되는 형태를 GTID 기반 복제라 한다.

### GTID의 필요성

복제 구성이나 장애에 대한 복구 대책을 고민해본 사용자라면 누구나 바이너리 로그 파일의 위치 기반 복제 방식의 문제점을 알고 있다. 아래는 간단하게 우리가 자주 사용하는 복제 토폴로지 예시다.
  
하나의 소스 서버에 두 개의 레플리카 서버가 연결 돼 있는 복제 토폴로지다. 이러한 형태는 주로 레플리카 서버를 읽기 부하 분산 및 통계나 배치용으로 구성할 때 많이 사용한다.
  
현재 소스 서버 A의 바이너리 로그 위치는 `binary-log.000002:320`이며, 레플리카 서버 B는 완전히 동기화 되어 똑같이 `binary-log.000002:320` 바이너리 로그 이벤트까지 완전히 실행 완료된 상태다. B 서버는 SELECT 쿼리 분산용으로, C 서버는 배치나 통계용으로 사용되고 있었다. 그런데 레플리카 서버 C는 조금 지연이 발생해서 소스 서버의 `binary-log.000002:120` 위치까지만 복제가 동기화된 상태였다.

![image](https://github.com/user-attachments/assets/198da30f-5e1e-4b84-a857-c1f5ef62eb00)

그런데 이때 소스 서버인 A가 장애가 발생하면서 서버가 비정상적으로 종료됐다고 가정해보자. 그러면 레플리카 서버 B와 C 중에서 하나를 소스 서버로 승격하고, A 서버로 연결돼 있던 클라이언트 커넥션을 새로 승격된 소스 서버로 교체하고자 할 것이다. 이 때 당연히 완전히 동기화돼 있는 레플리카 서버 B를 소스 서버로 승격할 것이다. 이제 그럼 복제는 모두 끊어지고 B 서버로 사용자 트래픽이 유입되고 있다. 그러나 C 서버는 여전히 동기화되지 않은 상태여서 서비스에서 SELECT 용도로 사용할 수가 없는 상태다.

![image](https://github.com/user-attachments/assets/dc084921-3ff8-46a5-ab91-887d15abd12a)

B 서버가 새로운 소스 서버로 승격되면서 클라이언트의 쿼리 요청이 B 서버로 들어오기 시작하는데, 이미 B 서버는 SELECT 쿼리의 부하 분산용이었기 때문에 분산 SELECT 쿼리의 부하 분산용이었기 때문에 분산 SELECT 쿼리 처리와 더불어 기존 서스 서버의 역할까지 겹치면서 과부하 상태가 된다. C는 동기화가 되지 않은 상태여서 SELECT 쿼리를 옮길 수도 없고, A 서버가 종료돼 버렸으므로 복제를 최종 시점까지 동기화할 방법이 없다.

### GTID

GTID는 논리적인 의미로서 물리적인 파일의 이름이나 위치와는 전혀 무관하게 생성된다. MySQL의 GTID는 커밋된 각 트랜잭션과 연결된 고유 식별자로, 해당 트랜잭션이 발생한 서버에서 고유할뿐만 아니라 그 서버가 속한 복제 토폴로지 내 모든 서버에서 고유하다. GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며, 데이터 읽기만 수행하는 SELECT 쿼리나 혹은 sql_log_bin 설정이 비활성화돼 있는 상태에서 발생한 트랜잭션은 바이너리 로그에 기록되지 않으므로 GTID가 할당되지 않는다.
  
GTID는 소스 아이디와 트랜잭션 아이디 값의 조합으로 생성되고 :로 구분되어 표시된다. 현재 사용되고 있는 GTID 값을 확인하는 방법에는 여러 가지가 있는데, mysql 데이터베이스 내의 `gtid_executed 테이블`을 조회하거나 `gtid_executed 시스템 변수`를 통해 확인할 수 있따. 또한 SHOW MASTER STATUS 명령을 통해 GTID와 이에 상응하는 바이너리 로그 파일 및 위치 값을 같이 확인할 수도 있다.

## 복제 데이터 포맷

바이너리 로그에 이벤트가 어떤 포맷으로 기록되는지는 복제가 처리되는 과정에도 영향을 준다. 레플리카 서버의 소스 서버의 바이너리 로그 이벤트를 내부적으로 가공하지 않고 가져온 그대로 실행해서 데이터에 적용하기 떄문이다.
  
MySQL에서는 실행된 SQL문을 바이너리 로그에 기록하는 `Statement` 방식과 변경된 데이터 자체를 기록하는 `Row` 방식으로 두 종류의 바이너리 로그 포맷을 제공하며, 사용자는 `binlog_format` 시스템 변수를 통해 이 두가지 종류 중 하나로 설정하거나 혹은 혼합된 형태로 사용하도록 설정할 수 있다.

### Statement 기반 바이너리 로그 포맷

Statement 기반 바이너리 로그 포맷은 MySQL에 바이너리 로그가 처음 도입됐을 떄부터 존재해왔던 포맷으로, 앞서 언급한 바와 같이 변경 이벤트에 대해 이벤트를 발생시킨 SQL문을 바이너리 로그에 기록하는 방식이다. 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데 이 경우 Statement 포맷에서는 바이너리 로그에 SQL문 하나만 기록된다. 바이너리 로그는 변경 내역이 전부 저장되는 파일이므로 감사 등의 목적으로도 활용될 수 있는데, Statement 포맷을 사용하면 손쉽게 SQL문을 확인할 수 있으므로 감사에 더 용이하다고 할 수 있다.
  
몇 가지 단점들도 있다. 대표적인 단점은 비확정적으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.

- DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
- SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
- LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같이 함수를 사용하는 쿼리
- 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리

Statement 포맷의 또 다른 단점은 Row 포맷으로 복제될 때보다 데이터에 락을 더 많이 건다는 점이다. INSERT INTO ... SELECT 구문이 대표적인 경우이고 그 외에 데이터 검색 조건으로 주어진 칼럼에 대해 적절한 인덱스가 테이블에 존재하지 않아 풀 테이블 스캔을 유발하는 UPDATE 쿼리가 실행된 경우 등이 있다.
  
Statement 기반 바이너리 로그 포맷은 또한 트랜잭션 격리 수준이 반드시 `REPEATABLE-READ` 이상이어야 한다는 제한사항이 있다. 그 이하 방식에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라질 수 있는데, 이로 인해 복제 시 소스 서버와 레플리카 서버의 데이터가 일치하지 않게 될 수 있으므로 Statement 포맷 사용이 허용되지 않는다.

### Row 기반 바이너리 로그 포맷

Row 기반 바이너리 로그 포맷은 MySQL 5.1버전부터 도입된 포맷으로, 데이터 변경이 발생했을 떄 변경된 값 자체가 바이너리 로그에 기록되는 방식이다. 어떤 형태의 쿼리가 실행됐든 간에 복제시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식이다.
