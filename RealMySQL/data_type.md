# 데이터 타입

칼럼의 데이터 타입과 길이를 선정할 때 가장 주의할 사항은 다음과 같다.

- 저장되는 값의 성격에 맞는 최적의 타입 선정
- 가변 길이 칼럼은 최적의 길이 선정
- 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입으로 선정


## 문자열(CHAR와 VARCHAR)

### 저장 공간

CHAR와 VARCHAR의 공통점은 문자열을 저장할 수 있는 데이터 타입이라는 점이고, 가장 큰 차이는 고정 길이냐 가변 길이냐다.
  
하나의 글자가 CHAR 타입에 저장될 때는 추가 공간이 더 필요하지 않지만 VARCHAR 타입에 저장할 때는 문자열의 길이를 관리하기 위한
1~2 바이트의 공간을 추가로 더 사용한다. VARCHAR 타입의 길이가 255바이트 이하이면 1바이트만 사용하고, 256바이트 이상으로 설정되면
2바이트를 사용한다. VARCHAR 타입의 길이 관리 최대 바이트는 2바이트로, 즉 VARCHAR 타입의 최대 길이는 65,536 바이트이다.
  
사람들은 보통 길이가 고정적일 때 CHAR를 선택하고, 길이가 가변적일 때 VARCHAR를 선택한다. 하지만 실제로 길이가 정적이냐
가변적이냐만으로 CHAR와 VARCHAR 타입을 결정하는 것은 적절하지 않다.

- 저장되는 문자열의 길이가 대개 비슷한지
- 칼럼의 값이 자주 변경되는지

CHAR와 VARCHAR 타입의 선택 기준은 값의 길이도 중요하지만, 해당 칼럼의 값이 얼마나 자주 변경되느냐가 기준이 돼야 한다.

```sql
CREATE TABLE tb_test (
    fd1 INT NOT NULL,
    fd2 CHAR(10) NOT NULL,
    fd3 DATETIME NOT NULL
);

INSERT INTO tb_test (fd1, fd2, fd3) VALUES (1, 'ABCD', '2011-06-27 11:02:11');
```

![image](https://github.com/user-attachments/assets/9d15f078-2ebd-4a36-bc70-22367d874fa4)
![image](https://github.com/user-attachments/assets/2608f439-0b60-41a5-bbb9-5f20ba2e4780)

여기서 만약 fd2 칼럼의 값을 "ABCDE"로 UPDATE했다고 가정한다면

- CHAR(10) 타입에서는 fd2 칼럼을 위해 공간이 10바이트가 준비돼 있으므로 그냥 변경되는 칼럼의 값을 업데이트만 하면 된다.
- VARCHAR(10) 타입에서는 fd2 칼럼에 4바이트 밖에 저장할 수 없는 구조로 만들어져 있다. 그래서 "ABCDE"와 같이 길이가 더 큰 값으로 변경될 때는 레코드 자체를 다른 공간으로 옮겨서(Row migration) 저장 해야 한다.

물론 주민등록번호처럼 항상 값의 길이가 고정적일 때는 당연히 CHAR 타입을 사용해야 한다. 또한 값이 2~3바이트씩 차이가 나더라도 자주 변경될 수 있는
부서 번호나 게시물의 상태 값 등은 CHAR 타입을 사용하는 것이 좋다. 자주 변경돼도 레코드가 물리적으로 다른 위치로 이동하거나 분리되지 않아도 되기 때문이다.

### 저장 공간과 스키마 변경(Online DDL)

VARCHAR 데이터 타입을 사용하는 칼럼의 길이를 늘리는 작업은 길이에 따라 매우 빠르게 처리될 수도 있지만 어떤 경우에는 테이블에 대해 읽기 잠금을 걸고
레코드를 복사하는 작업이 필요할 수도 있다.

```sql
CREATE TABLE test (
    id INT PRIMARY KEY,
    value VARCHAR(60)
) DEFAULT CHARSET=utf8mb4;
```

```sql
ALTER TABLE test MODIFY value VARCHAR(63), ALGORITHM=INPLACE, LOCK=NONE;
Query OK, 0 rows affected (0.00 sec)

ALTER TABLE test MODIFY value VARCHAR(64), ALGORITHM=INPLCAE, LOCK=NONE;
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
```

value 칼럼의 길이를 VARCHAR(63)으로 늘리는 경우는 잠금 없이 매우 빠르게 변경되지만, VARCHAR(64)로 늘리는 경우는 INPLACE 알고리즘으로
스키마 변경이 허용되지 않는다. 
  
VARCHAR(64)로 변경하는 경우에는 다음과 같이 COPY 알고리즘으로 스키마 변경을 실행했으며, 스키마 변경 시간도 상당히 많이 걸리게 된다. 
COPY 알고리즘의 스키마 변경은 읽기 잠금까지 필요로 한다. 즉 스키마 변경을 하는 동안 test 테이블에는 INSERT나 UPDATE, DELETE를 실행할 수 없게된다.
  
이러한 차이가 발생하는 이유는 VARCHAR 타입의 컬럼이 가지는 길이 저장 공간 크기 때문이다. utf8mb4 문자 집합을 사용하는 VARCHAR(60) 칼럼은
최대 길이가 240바이트이기 떄문에 문자열 값 길이를 저장하는 공간이 1바이트면 되지만, VARCHAR(64) 타입은 저장할 수 있는 
문자열의 크기가 최대 256 바이트이기 때문에 문자열 길이를 저장하는 공간의 크기를 2바이트로 변경해야 한다.
  
문자열 길이를 저장하는 공간의 크기가 바뀌게 되면 MySQL 서버는 스키마 변경을 하는 동안 읽기 잠금을 걸어서 아무도 데이터를 변경하지 못하도록
막고 테이블의 레코드를 복사하는 방식으로 처리한다. 레코드 건수가 많은 테이블에서 읽기 잠금을 필요로 하는 스키마 변경을 실행하기 위해 스키마를 변경할 때마다 
서비스의 가용성이 훼손될 수 있다.

## 콜레이션

콜레이션은 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙을 의미한다. MySQL의 모든 문자열 타입 칼럼은 독립적인 문자 집합과 콜레이션을 가진다.
각 칼럼에 대해 독립적으로 지정하지 않으면 MySQL 서버나 DB 기본 문자 집합과 콜레이션이 자동으로 설정된다.

### 콜레이션 이해

문자 집합은 2개 이상의 콜레이션을 가지고 있는데, 하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해서 사용할 수 없다.
또한 테이블이나 칼럼에 문자 집합만 지정하면 해당 문자 집합의 기본 콜레이션이 해당 칼럼의 콜레이션으로 지정된다.

- `utf8mb4_0900_ai_ci`
  - 3개의 파트로 구성된 콜레이션 이름
  - 첫 번째 파트: 문자 집합의 이름
  - 두 번째 파트: 해당 문자 집합의 하위 분류
  - 세 번째 파트: 대문자나 소문자의 구분 여부를 나타낸다.
    - `ci`이면 대소문자를 구분하지 않는 콜레이션이며, `cs`이면 대소문자를 별도의 문자로 구분하는 콜레이션이다.
  - `ai` 또는 `as`는 액센트를 가진 문자와 그렇지 않은 문자를 동일 문자로 판단할지 여부를 나타낸다.
  
- `uf8mb4_bin`
  - 첫 번째 파트: 문자 집합의 이름
  - 두 번쨰 파트: 항상 bin 이라는 키워드가 사용된다. bin은 이진 데이터를 의미하며 이진 데이터로 관리되는 문자열 칼럼은 별도의 콜레이션을 가지지 않는다.

허ㅗ 
- 
